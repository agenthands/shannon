# Shannon Vulnerability Validation & Exploitation Code Review

**Document Version:** 1.0
**Last Updated:** 2025-02-02
**Purpose:** Deep dive into Shannon's validation and exploitation mechanisms

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Validation Architecture](#validation-architecture)
3. [Queue-Based Validation System](#queue-based-validation-system)
4. [Agent Output Validation](#agent-output-validation)
5. [Exploitation Workflow](#exploitation-workflow)
6. [Error Handling & Retry Logic](#error-handling--retry-logic)
7. [MCP Server Integration](#mcp-server-integration)
8. [Critical Code Paths](#critical-code-paths)
9. [Security & Reliability Features](#security--reliability-features)

---

## Executive Summary

Shannon implements a **sophisticated multi-layered validation and exploitation system** with the following key characteristics:

1. **Queue-Based Gating** - Exploitation agents only run if vulnerabilities are found in queues
2. **Dual Deliverable Requirement** - Vulnerability agents must create both analysis report AND queue file
3. **Conditional Exploitation** - Each vulnerability type independently decides whether to exploit
4. **Pipelined Parallelism** - No synchronization barriers; exploits start immediately after their vuln agent completes
5. **Graceful Failure** - One pipeline failure doesn't stop others
6. **Git Checkpointing** - Every agent execution wrapped in checkpoint/commit/rollback

**Key Design Philosophy:** "No Exploit, No Report" - Only successfully exploited vulnerabilities reach the final report.

---

## Validation Architecture

### Three-Layer Validation System

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 1: MCP Tool Validation (Real-time)                    â”‚
â”‚                                                            â”‚
â”‚ save_deliverable MCP tool validates on save:               â”‚
â”‚ â€¢ Queue files: JSON structure validation                  â”‚
â”‚ â€¢ All files: Automatic filename assignment                 â”‚
â”‚ â€¢ Returns: { status, filepath, validated }                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 2: Agent Output Validation (Post-execution)           â”‚
â”‚                                                            â”‚
â”‚ validateAgentOutput() in claude-executor.ts:             â”‚
â”‚ â€¢ Check agent completed successfully                       â”‚
â”‚ â€¢ Run agent-specific validator function                     â”‚
â”‚ â€¢ Validate required files exist                            â”‚
â”‚ â€¢ Returns: boolean (pass/fail)                             â”‚
â”‚                                                            â”‚
â”‚ If fail: Rollback git, retry agent (max 3 times)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 3: Queue Validation (Pre-exploitation)               â”‚
â”‚                                                            â”‚
â”‚ checkExploitationQueue() in activities.ts:                â”‚
â”‚ â€¢ Validate deliverable + queue symmetry                   â”‚
â”‚ â€¢ Validate queue JSON structure                           â”‚
â”‚ â€¢ Check vulnerability count > 0                           â”‚
â”‚ â€¢ Returns: ExploitationDecision { shouldExploit }        â”‚
â”‚                                                            â”‚
â”‚ If fail: Skip exploitation or retry vuln agent             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Queue-Based Validation System

### Core File: `src/queue-validation.ts`

#### Type Definitions

```typescript
export type VulnType = 'injection' | 'xss' | 'auth' | 'ssrf' | 'authz';

export interface ExploitationDecision {
  shouldExploit: boolean;      // GATEKEEPER: Run exploit agent or skip?
  shouldRetry: boolean;        // Retryable error (re-run vuln agent)
  vulnerabilityCount: number;  // Number of vulns in queue
  vulnType: VulnType;          // Vulnerability type
}

export interface SafeValidationResult {
  success: boolean;
  data?: ExploitationDecision;
  error?: PentestError;        // Classified error with retryable flag
}
```

#### Vulnerability Type Configuration

```typescript
const VULN_TYPE_CONFIG = Object.freeze({
  injection: {
    deliverable: 'injection_analysis_deliverable.md',
    queue: 'injection_exploitation_queue.json',
  },
  xss: {
    deliverable: 'xss_analysis_deliverable.md',
    queue: 'xss_exploitation_queue.json',
  },
  // ... auth, ssrf, authz
});
```

**Key Design:** Immutable configuration ensures type safety and prevents runtime modifications.

---

### Validation Pipeline: Functional Composition

```typescript
// Main validation pipeline using asyncPipe
export async function validateQueueAndDeliverable(
  vulnType: VulnType,
  sourceDir: string
): Promise<ExploitationDecision> {
  return asyncPipe<ExploitationDecision>(
    createPaths(vulnType, sourceDir),         // Step 1: Build file paths
    checkFileExistence,                       // Step 2: Check files exist
    validateExistenceRules,                   // Step 3: Validate symmetry
    validateQueueContent,                     // Step 4: Validate JSON structure
    determineExploitationDecision             // Step 5: Make decision
  );
}
```

**Functional Programming Benefits:**
- **Pure functions** - Each step is testable in isolation
- **Composability** - Pipeline can be extended with new validation steps
- **Error propagation** - Errors short-circuit the pipeline automatically

---

### Step 1: Path Creation

```typescript
const createPaths = (vulnType: VulnType, sourceDir: string) => {
  const config = VULN_TYPE_CONFIG[vulnType];

  return Object.freeze({
    vulnType,
    deliverable: path.join(sourceDir, 'deliverables', config.deliverable),
    queue: path.join(sourceDir, 'deliverables', config.queue),
    sourceDir,
  });
};
```

**Example Output:**
```typescript
{
  vulnType: 'injection',
  deliverable: '/target/repo/deliverables/injection_analysis_deliverable.md',
  queue: '/target/repo/deliverables/injection_exploitation_queue.json',
  sourceDir: '/target/repo'
}
```

---

### Step 2: File Existence Check

```typescript
const checkFileExistence = async (paths: PathsBase) => {
  const [deliverableExists, queueExists] = await Promise.all([
    fs.pathExists(paths.deliverable),
    fs.pathExists(paths.queue),
  ]);

  return {
    ...paths,
    existence: { deliverableExists, queueExists }
  };
};
```

**Parallel Execution:** Uses `Promise.all` to check both files simultaneously for efficiency.

---

### Step 3: Existence Rules Validation

```typescript
// Symmetric deliverable rules: queue and deliverable must exist together
const fileExistenceRules = Object.freeze([
  createValidationRule(
    ({ deliverableExists, queueExists }) =>
      deliverableExists && queueExists,  // BOTH must exist
    getExistenceErrorMessage
  ),
]);
```

**Why Symmetry Matters:**

Prevents partial analysis from triggering exploitation:
- âœ… **Both exist:** Agent completed successfully, proceed to validation
- âŒ **Neither exists:** Agent failed completely, retry vuln agent
- âŒ **Only deliverable exists:** Agent didn't create queue, retry vuln agent
- âŒ **Only queue exists:** Agent didn't create deliverable (unlikely), retry vuln agent

**Error Messages:**

```typescript
function getExistenceErrorMessage(existence: FileExistence): string {
  if (!existence.deliverableExists && !existence.queueExists) {
    return 'Analysis failed: Neither deliverable nor queue file exists.';
  }
  if (!existence.queueExists) {
    return 'Analysis incomplete: Deliverable exists but queue file missing.';
  }
  return 'Analysis incomplete: Queue exists but deliverable file missing.';
}
```

---

### Step 4: Queue Structure Validation

```typescript
const validateQueueStructure = (content: string): QueueValidationResult => {
  try {
    const parsed = JSON.parse(content);

    // Structure must be: { "vulnerabilities": [...] }
    const isValid =
      typeof parsed === 'object' &&
      parsed !== null &&
      'vulnerabilities' in parsed &&
      Array.isArray(parsed.vulnerabilities);

    return {
      valid: isValid,
      data: isValid ? parsed : null,
      error: null
    };
  } catch (parseError) {
    return {
      valid: false,
      data: null,
      error: parseError.message
    };
  }
};
```

**Validation Rules:**
1. Must be valid JSON
2. Must be an object (not array, not null)
3. Must have `vulnerabilities` property
4. `vulnerabilities` must be an array

**Error Handling:**

```typescript
if (!queueValidation.valid) {
  return {
    error: new PentestError(
      `Queue validation failed for ${vulnType}: Invalid JSON structure.
       Analysis agent must fix queue format.`,
      'validation',
      true,  // retryable - agent can fix malformed JSON on retry
      { vulnType, queuePath, originalError }
    )
  };
}
```

---

### Step 5: Exploitation Decision

```typescript
const determineExploitationDecision = (validatedData: PathsWithQueue) => {
  const hasVulnerabilities = validatedData.queueData.vulnerabilities.length > 0;

  return Object.freeze({
    shouldExploit: hasVulnerabilities,  // GATEKEEPER
    shouldRetry: false,                  // No retry at this stage
    vulnerabilityCount: validatedData.queueData.vulnerabilities.length,
    vulnType: validatedData.vulnType,
  });
};
```

**Decision Matrix:**

| Queue File | Vulnerability Count | shouldExploit | Action |
|------------|-------------------|---------------|---------|
| Doesn't exist | N/A | false | Validation error, retryable |
| Invalid JSON | N/A | false | Validation error, retryable |
| Exists, empty array | 0 | false | Skip exploitation (no vulns found) |
| Exists, has items | >0 | **true** | **Run exploitation** âœ“ |

---

### Safe Validation API

```typescript
export const safeValidateQueueAndDeliverable = async (
  vulnType: VulnType,
  sourceDir: string
): Promise<SafeValidationResult> => {
  try {
    const result = await validateQueueAndDeliverable(vulnType, sourceDir);
    return { success: true, data: result };
  } catch (error) {
    return {
      success: false,
      error: error as PentestError
    };
  }
};
```

**Usage:** Called by `checkExploitationQueue` activity to prevent workflow interruption.

---

## Agent Output Validation

### Core File: `src/ai/claude-executor.ts`

#### Validation Function

```typescript
export async function validateAgentOutput(
  result: ClaudePromptResult,
  agentName: string | null,
  sourceDir: string
): Promise<boolean> {
  console.log(chalk.blue(`Validating ${agentName} agent output`));

  // Check 1: Agent completed successfully
  if (!result.success || !result.result) {
    console.log(chalk.red('Validation failed: Agent execution was unsuccessful'));
    return false;
  }

  // Check 2: Get validator function for this agent
  const validator = AGENT_VALIDATORS[agentName];

  if (!validator) {
    console.log(chalk.yellow(`No validator found for "${agentName}" - assuming success`));
    return true;
  }

  // Check 3: Apply validation function
  const validationResult = await validator(sourceDir);

  if (validationResult) {
    console.log(chalk.green('Validation passed: Required files/structure present'));
  } else {
    console.log(chalk.red('Validation failed: Missing required deliverable files'));
  }

  return validationResult;
}
```

**Validation Flow:**
```
Agent completes â†’ Check success flag â†’ Look up validator â†’ Check files exist â†’ Return result
```

---

### Agent Validators: `src/constants.ts`

#### Vulnerability Agent Validators

```typescript
function createVulnValidator(vulnType: VulnType): AgentValidator {
  return async (sourceDir: string): Promise<boolean> => {
    try {
      // Calls the full validation pipeline from queue-validation.ts
      await validateQueueAndDeliverable(vulnType, sourceDir);
      return true;
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.log(chalk.yellow(`Queue validation failed for ${vulnType}: ${errMsg}`));
      return false;  // Validation failed
    }
  };
}

// Usage
export const AGENT_VALIDATORS = {
  'injection-vuln': createVulnValidator('injection'),
  'xss-vuln': createVulnValidator('xss'),
  'auth-vuln': createVulnValidator('auth'),
  'ssrf-vuln': createVulnValidator('ssrf'),
  'authz-vuln': createVulnValidator('authz'),
  // ...
};
```

**What This Validates:**
1. Analysis deliverable exists (`*_analysis_deliverable.md`)
2. Queue file exists (`*_exploitation_queue.json`)
3. Queue has valid JSON structure
4. Queue contains `vulnerabilities` array

**Why Call `validateQueueAndDeliverable`:**
- Ensures dual deliverable requirement
- Validates queue JSON structure
- Provides rich error messages for debugging
- Sets up exploitation decision for next phase

---

#### Exploitation Agent Validators

```typescript
function createExploitValidator(vulnType: VulnType): AgentValidator {
  return async (sourceDir: string): Promise<boolean> => {
    const evidenceFile = path.join(
      sourceDir,
      'deliverables',
      `${vulnType}_exploitation_evidence.md`
    );
    return await fs.pathExists(evidenceFile);
  };
}

// Usage
export const AGENT_VALIDATORS = {
  'injection-exploit': createExploitValidator('injection'),
  'xss-exploit': createExploitValidator('xss'),
  'auth-exploit': createExploitValidator('auth'),
  'ssrf-exploit': createExploitValidator('ssrf'),
  'authz-exploit': createExploitValidator('authz'),
  // ...
};
```

**What This Validates:**
- Exploitation agent created evidence file
- File contains exploitation results (successful or not)

**Simpler Validation:** Exploitation agents only need to create one file (evidence report), no queue needed.

---

#### Sequential Agent Validators

```typescript
export const AGENT_VALIDATORS = {
  'pre-recon': async (sourceDir: string): Promise<boolean> => {
    const codeAnalysisFile = path.join(
      sourceDir,
      'deliverables',
      'code_analysis_deliverable.md'
    );
    return await fs.pathExists(codeAnalysisFile);
  },

  'recon': async (sourceDir: string): Promise<boolean> => {
    const reconFile = path.join(
      sourceDir,
      'deliverables',
      'recon_deliverable.md'
    );
    return await fs.pathExists(reconFile);
  },

  'report': async (sourceDir: string): Promise<boolean> => {
    const reportFile = path.join(
      sourceDir,
      'deliverables',
      'comprehensive_security_assessment_report.md'
    );
    const reportExists = await fs.pathExists(reportFile);

    if (!reportExists) {
      console.log(chalk.red('âŒ Missing required deliverable: comprehensive_security_assessment_report.md'));
    }

    return reportExists;
  },
};
```

**Validation Pattern:** Sequential agents validate single deliverable file existence.

---

## Exploitation Workflow

### Core File: `src/temporal/workflows.ts`

#### Pipelined Parallel Execution

```typescript
// === Phases 3-4: Vulnerability Analysis + Exploitation (Pipelined) ===
state.currentPhase = 'vulnerability-exploitation';

// Helper: Run a single vulnâ†’exploit pipeline
async function runVulnExploitPipeline(
  vulnType: VulnType,
  runVulnAgent: () => Promise<AgentMetrics>,
  runExploitAgent: () => Promise<AgentMetrics>
): Promise<VulnExploitPipelineResult> {

  // Step 1: Run vulnerability agent
  const vulnMetrics = await runVulnAgent();

  // Step 2: Check exploitation queue (starts immediately after vuln)
  const decision = await a.checkExploitationQueue(activityInput, vulnType);

  // Step 3: Conditionally run exploit agent
  let exploitMetrics: AgentMetrics | null = null;
  if (decision.shouldExploit) {
    exploitMetrics = await runExploitAgent();
  }

  return {
    vulnType,
    vulnMetrics,
    exploitMetrics,
    exploitDecision: {
      shouldExploit: decision.shouldExploit,
      vulnerabilityCount: decision.vulnerabilityCount,
    },
    error: null,
  };
}

// Run all 5 pipelines in parallel with graceful failure handling
const pipelineResults = await Promise.allSettled([
  runVulnExploitPipeline(
    'injection',
    () => a.runInjectionVulnAgent(activityInput),
    () => a.runInjectionExploitAgent(activityInput)
  ),
  runVulnExploitPipeline(
    'xss',
    () => a.runXssVulnAgent(activityInput),
    () => a.runXssExploitAgent(activityInput)
  ),
  // ... auth, ssrf, authz
]);
```

**Key Characteristics:**

1. **Pipelined Execution:** No synchronization barrier
   ```
   injection-vuln â†’ queue-check â†’ injection-exploit
   xss-vuln        â†’ queue-check â†’ xss-exploit
   auth-vuln        â†’ queue-check â†’ auth-exploit
   ```

2. **Independent Start Times:** Each exploit starts immediately after its vuln agent completes
   - If injection-vuln finishes in 10min, injection-exploit starts at 10min
   - If xss-vuln finishes in 15min, xss-exploit starts at 15min
   - No waiting for other vuln agents

3. **Graceful Failure:** Uses `Promise.allSettled` instead of `Promise.all`
   - One pipeline failure doesn't stop others
   - Failed pipelines logged but workflow continues
   - Failed vuln agents are retried by Temporal

4. **Conditional Exploitation:** `if (decision.shouldExploit)` gate
   - If queue is empty: Skip exploitation, save time and API calls
   - If queue has items: Run exploitation

---

### Activity: checkExploitationQueue

**File:** `src/temporal/activities.ts` (lines 407-443)

```typescript
export async function checkExploitationQueue(
  input: ActivityInput,
  vulnType: VulnType
): Promise<ExploitationDecision> {
  const { repoPath } = input;

  // Safe validation - never throws
  const result = await safeValidateQueueAndDeliverable(vulnType, repoPath);

  // Success: Return decision
  if (result.success && result.data) {
    const { shouldExploit, vulnerabilityCount } = result.data;
    console.log(
      chalk.blue(
        `ğŸ” ${vulnType}: ${shouldExploit
          ? `${vulnerabilityCount} vulnerabilities found`
          : 'no vulnerabilities, skipping exploitation'}`
      )
    );
    return result.data;
  }

  // Validation failed - check if we should retry or skip
  const error = result.error;

  if (error?.retryable) {
    // Re-throw retryable errors so Temporal can retry the vuln agent
    console.log(chalk.yellow(`âš ï¸ ${vulnType}: ${error.message} (retrying)`));
    throw error;
  }

  // Non-retryable error - skip exploitation gracefully
  console.log(
    chalk.yellow(`âš ï¸ ${vulnType}: ${error?.message ?? 'Unknown error'}, skipping exploitation`)
  );

  return {
    shouldExploit: false,
    shouldRetry: false,
    vulnerabilityCount: 0,
    vulnType,
  };
}
```

**Error Handling Strategy:**

| Error Type | Behavior | Example |
|-----------|----------|---------|
| **Retryable** | Re-throw error | Missing files, invalid JSON (agent can fix) |
| **Non-retryable** | Skip exploitation | Permanent configuration errors |

**Why Re-throw Retryable Errors:**
- Temporal will retry the vulnerability agent
- Agent gets chance to fix malformed JSON on retry
- Example: Agent forgot to create queue file â†’ retry â†’ creates both files â†’ success

---

### Activity: runAgentActivity (Wrapper)

**File:** `src/temporal/activities.ts` (lines 108-304)

```typescript
async function runAgentActivity(
  agentName: AgentName,
  input: ActivityInput
): Promise<AgentMetrics> {
  const startTime = Date.now();
  const attemptNumber = Context.current().info.attempt;

  // Heartbeat loop - signals worker is alive to Temporal server
  const heartbeatInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    heartbeat({ agent: agentName, elapsedSeconds: elapsed, attempt: attemptNumber });
  }, HEARTBEAT_INTERVAL_MS);  // 2 seconds

  try {
    // 1. Load config (if provided)
    let distributedConfig: DistributedConfig | null = null;
    if (configPath) {
      const config = await parseConfig(configPath);
      distributedConfig = distributeConfig(config);
    }

    // 2. Initialize audit session
    const sessionMetadata: SessionMetadata = {
      id: workflowId,
      webUrl,
      repoPath,
      ...(outputPath && { outputPath }),
    };
    const auditSession = new AuditSession(sessionMetadata);
    await auditSession.initialize();

    // 3. Load prompt
    const prompt = await loadPrompt(
      promptName,
      { webUrl, repoPath },
      distributedConfig,
      pipelineTestingMode
    );

    // 4. Create git checkpoint before execution
    await createGitCheckpoint(repoPath, agentName, attemptNumber);
    await auditSession.startAgent(agentName, prompt, attemptNumber);

    // 5. Execute agent (single attempt - Temporal handles retries)
    const result: ClaudePromptResult = await runClaudePrompt(
      prompt,
      repoPath,
      '',  // context
      agentName,
      agentName,
      chalk.cyan,
      sessionMetadata,
      auditSession,
      attemptNumber
    );

    // 6. Sanity check: Detect spending cap that slipped through
    if (result.success && result.turns <= 2 && result.cost === 0) {
      const resultText = result.result || '';
      const looksLikeBillingError = /spending|cap|limit|budget|resets/i.test(resultText);

      if (looksLikeBillingError) {
        await rollbackGitWorkspace(repoPath, 'spending cap detected');
        throw new Error(`Spending cap likely reached: ${resultText.slice(0, 100)}`);
      }
    }

    // 7. Handle execution failure
    if (!result.success) {
      await rollbackGitWorkspace(repoPath, 'execution failure');
      await auditSession.endAgent(agentName, {
        attemptNumber,
        duration_ms: result.duration,
        cost_usd: result.cost || 0,
        success: false,
        model: result.model,
        error: result.error || 'Execution failed',
      });
      throw new Error(result.error || 'Agent execution failed');
    }

    // 8. Validate output
    const validationPassed = await validateAgentOutput(result, agentName, repoPath);
    if (!validationPassed) {
      await rollbackGitWorkspace(repoPath, 'validation failure');
      await auditSession.endAgent(agentName, {
        attemptNumber,
        duration_ms: result.duration,
        cost_usd: result.cost || 0,
        success: false,
        model: result.model,
        error: 'Output validation failed',
      });

      // Limit output validation retries (unlikely to self-heal)
      if (attemptNumber >= MAX_OUTPUT_VALIDATION_RETRIES) {
        throw ApplicationFailure.nonRetryable(
          `Agent ${agentName} failed output validation after ${attemptNumber} attempts`,
          'OutputValidationError',
          [{ agentName, attemptNumber, elapsed: Date.now() - startTime }]
        );
      }
      throw new Error(`Agent ${agentName} failed output validation`);
    }

    // 9. Success - commit and log
    const commitHash = await getGitCommitHash(repoPath);
    await auditSession.endAgent(agentName, {
      attemptNumber,
      duration_ms: result.duration,
      cost_usd: result.cost || 0,
      success: true,
      model: result.model,
      ...(commitHash && { checkpoint: commitHash }),
    });
    await commitGitSuccess(repoPath, agentName);

    // 10. Return metrics
    return {
      durationMs: Date.now() - startTime,
      costUsd: result.cost ?? null,
      numTurns: result.turns ?? null,
      model: result.model,
    };
  } catch (error) {
    // Rollback git workspace before Temporal retry
    await rollbackGitWorkspace(repoPath, 'error recovery');

    // Classify error for Temporal retry behavior
    const classified = classifyErrorForTemporal(error);

    if (classified.retryable) {
      // Temporal will retry with configured backoff
      const failure = ApplicationFailure.create({
        message: truncateErrorMessage(error.message),
        type: classified.type,
        details: [{ agentName, attemptNumber, elapsed: Date.now() - startTime }],
      });
      throw failure;
    } else {
      // Fail immediately - no retry
      const failure = ApplicationFailure.nonRetryable(
        truncateErrorMessage(error.message),
        classified.type,
        [{ agentName, attemptNumber, elapsed: Date.now() - startTime }]
      );
      throw failure;
    }
  } finally {
    clearInterval(heartbeatInterval);
  }
}
```

**Key Features:**

1. **Heartbeat Loop** (2s interval)
   - Signals worker liveness to Temporal server
   - Prevents Temporal from marking activity as timed out
   - Critical for long-running agents (up to 2 hours)

2. **Git Checkpoint System**
   - **Before execution:** Create checkpoint
   - **On success:** Commit changes
   - **On failure:** Rollback to clean state

3. **Spending Cap Detection**
   - Sanity check for â‰¤2 turns with $0 cost
   - Prevents billing errors from slipping through
   - Triggers rollback and retry with long backoff

4. **Output Validation**
   - Validates required files exist
   - Limited to 3 retries (unlikely to self-heal)
   - Non-retryable after 3 attempts

5. **Error Classification**
   - Retryable: BillingError, TransientError (429, 5xx, network)
   - Non-retryable: AuthenticationError, PermissionError, ConfigurationError

6. **Audit Logging**
   - Session initialization
   - Agent start/end with metrics
   - Error context preservation

---

## MCP Server Integration

### Core File: `mcp-server/src/tools/save-deliverable.ts`

#### Tool Definition

```typescript
export const SaveDeliverableInputSchema = z.object({
  deliverable_type: z.nativeEnum(DeliverableType).describe('Type of deliverable to save'),
  content: z.string().min(1).describe('File content (markdown for analysis/evidence, JSON for queues)'),
});

function createSaveDeliverableHandler(targetDir: string) {
  return async function save_deliverable(args: SaveDeliverableInput): Promise<ToolResult> {
    const { deliverable_type, content } = args;

    // Validate queue JSON if applicable
    if (isQueueType(deliverable_type)) {
      const queueValidation = validateQueueJson(content);
      if (!queueValidation.valid) {
        const errorResponse = createValidationError(
          queueValidation.message ?? 'Invalid queue JSON',
          true,
          {
            deliverableType: deliverable_type,
            expectedFormat: '{"vulnerabilities": [...]}',
          }
        );
        return createToolResult(errorResponse);
      }
    }

    // Get filename and save file
    const filename = DELIVERABLE_FILENAMES[deliverable_type];
    const filepath = saveDeliverableFile(targetDir, filename, content);

    // Success response
    const successResponse: SaveDeliverableResponse = {
      status: 'success',
      message: `Deliverable saved successfully: ${filename}`,
      filepath,
      deliverableType: deliverable_type,
      validated: isQueueType(deliverable_type),
    };

    return createToolResult(successResponse);
  };
}
```

**Validation Logic:**

```typescript
// Queue validation in mcp-server/src/validation/queue-validator.ts
export function validateQueueJson(content: string): ValidationResult {
  try {
    const parsed = JSON.parse(content);

    // Type guard for the parsed result
    if (typeof parsed !== 'object' || parsed === null) {
      return {
        valid: false,
        message: `Invalid queue structure: Expected an object. Got: ${typeof parsed}`,
      };
    }

    const obj = parsed as Record<string, unknown>;

    // Queue files must have a 'vulnerabilities' array
    if (!('vulnerabilities' in obj)) {
      return {
        valid: false,
        message: `Invalid queue structure: Missing 'vulnerabilities' property. Expected: {"vulnerabilities": [...]}`,
      };
    }

    if (!Array.isArray(obj.vulnerabilities)) {
      return {
        valid: false,
        message: `Invalid queue structure: 'vulnerabilities' must be an array. Expected: {"vulnerabilities": [...]}`,
      };
    }

    return {
      valid: true,
      data: parsed as VulnerabilityQueue,
    };
  } catch (error) {
    return {
      valid: false,
      message: `Invalid JSON: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}
```

**Benefits of MCP Tool Validation:**

1. **Immediate Feedback** - Agent gets validation error instantly on tool call
2. **Rich Error Messages** - Tool response includes expected format
3. **Prevents Invalid Files** - Malformed JSON rejected before disk write
4. **Type Safety** - Zod schema ensures correct parameter types

---

## Error Handling & Retry Logic

### Error Classification: `src/error-handling.ts`

```typescript
export interface PentestError extends Error {
  type: string;          // Error category
  retryable: boolean;   // Should Temporal retry
  details?: Record<string, unknown>;
}

export function classifyErrorForTemporal(error: unknown): PentestError {
  // Extract error message and context
  const message = error instanceof Error ? error.message : String(error);

  // Check for billing errors (rate limits, spending caps)
  if (isBillingError(message)) {
    return {
      type: 'BillingError',
      message,
      retryable: true,  // Always retry billing errors
      name: 'PentestError',
    };
  }

  // Check for authentication errors
  if (isAuthenticationError(message)) {
    return {
      type: 'AuthenticationError',
      message,
      retryable: false,  // Don't retry auth failures
      name: 'PentestError',
    };
  }

  // Check for transient network errors
  if (isTransientError(message)) {
    return {
      type: 'TransientError',
      message,
      retryable: true,
      name: 'PentestError',
    };
  }

  // Check for configuration errors
  if (isConfigurationError(message)) {
    return {
      type: 'ConfigurationError',
      message,
      retryable: false,  // Config errors are permanent
      name: 'PentestError',
    };
  }

  // Default: retryable unknown errors
  return {
    type: 'UnknownError',
    message,
    retryable: true,
    name: 'PentestError',
  };
}
```

**Retry Configuration:**

```typescript
// From workflows.ts

// Production retry configuration
const PRODUCTION_RETRY = {
  initialInterval: '5 minutes',    // Wait 5min before first retry
  maximumInterval: '30 minutes',   // Max wait between retries
  backoffCoefficient: 2,           // Double interval each retry
  maximumAttempts: 50,             // Up to 50 retries for billing errors
  nonRetryableErrorTypes: [
    'AuthenticationError',
    'PermissionError',
    'InvalidRequestError',
    'RequestTooLargeError',
    'ConfigurationError',
    'InvalidTargetError',
    'ExecutionLimitError',
  ],
};

// Pipeline testing retry configuration (faster iteration)
const TESTING_RETRY = {
  initialInterval: '10 seconds',  // 10s wait
  maximumInterval: '30 seconds',
  backoffCoefficient: 2,
  maximumAttempts: 5,
  nonRetryableErrorTypes: PRODUCTION_RETRY.nonRetryableErrorTypes,
};
```

**Retry Strategy by Error Type:**

| Error Type | Retryable | Max Attempts | Backoff | Use Case |
|------------|-----------|---------------|---------|----------|
| BillingError | âœ… Yes | 50 | 5min â†’ 30min | Rate limits, spending caps |
| TransientError | âœ… Yes | 50 | 5min â†’ 30min | Network issues, 5xx errors |
| AuthenticationError | âŒ No | - | - | Invalid API keys (permanent) |
| ConfigurationError | âŒ No | - | - | Invalid YAML config |
| OutputValidationError | âœ… Yes | 3 | - | Agent forgot deliverable |
| Validation Error | âœ… Yes | 50 | 5min â†’ 30min | Queue JSON malformed |

---

## Critical Code Paths

### Path 1: Vulnerability Agent Execution Flow

```
User invokes ./shannon start
    â†“
Temporal workflow starts (workflows.ts)
    â†“
Phase 3: Vulnerability Analysis
    â†“
runInjectionVulnAgent(activityInput)
    â†“
runAgentActivity('injection-vuln', input)  [activities.ts]
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Load config                          â”‚
â”‚ 2. Initialize audit session             â”‚
â”‚ 3. Load prompt (vuln-injection.txt)   â”‚
â”‚ 4. Create git checkpoint               â”‚
â”‚ 5. Execute Claude Agent SDK             â”‚
â”‚    - Uses save_deliverable MCP tool    â”‚
â”‚    - Creates:                          â”‚
â”‚      â€¢ injection_analysis_deliverable.mdâ”‚
â”‚      â€¢ injection_exploitation_queue.jsonâ”‚
â”‚ 6. Validate output                      â”‚
â”‚    â†’ Uses AGENT_VALIDATORS['injection-vuln']â”‚
â”‚    â†’ Calls validateQueueAndDeliverable â”‚
â”‚ 7. If validation passed:               â”‚
â”‚    - Commit git changes                 â”‚
â”‚    - Log metrics                       â”‚
â”‚    - Return AgentMetrics                 â”‚
â”‚ 8. If validation failed:               â”‚
â”‚    - Rollback git workspace            â”‚
â”‚    - Retry agent (max 3 times)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Workflow continues to checkExploitationQueue
```

---

### Path 2: Queue Check â†’ Conditional Exploitation

```
Injection vuln agent completes successfully
    â†“
Workflow calls checkExploitationQueue(input, 'injection')
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ safeValidateQueueAndDeliverable()     â”‚
â”‚ [queue-validation.ts]                    â”‚
â”‚                                           â”‚
â”‚ Step 1: Build paths                     â”‚
â”‚   deliverable: '...injection_analysis_   â”‚
â”‚                deliverable.md'            â”‚
â”‚   queue: '...injection_exploitation_     â”‚
â”‚           queue.json'                    â”‚
â”‚                                           â”‚
â”‚ Step 2: Check file existence             â”‚
â”‚   await fs.pathExists(deliverable)     â”‚
â”‚   await fs.pathExists(queue)             â”‚
â”‚   â†’ Both must exist                     â”‚
â”‚                                           â”‚
â”‚ Step 3: Validate existence rules        â”‚
â”‚   deliverableExists && queueExists       â”‚
â”‚   â†’ If fail: throw PentestError         â”‚
â”‚                                           â”‚
â”‚ Step 4: Validate queue structure        â”‚
â”‚   JSON.parse(queueFile)                 â”‚
â”‚   Check: { "vulnerabilities": [...] }    â”‚
â”‚   â†’ If invalid JSON: throw error         â”‚
â”‚                                           â”‚
â”‚ Step 5: Make decision                   â”‚
â”‚   vulnerabilities.length > 0 ?             â”‚
â”‚     shouldExploit = true : false       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Return ExploitationDecision
    â”œâ”€ shouldExploit: true  â†’ Run injection-exploit agent
    â””â”€ shouldExploit: false â†’ Skip exploitation (mark complete)
```

---

### Path 3: Exploitation Agent Execution (Conditional)

```
checkExploitationQueue returns: shouldExploit=true, vulnerabilityCount=3
    â†“
Workflow calls runInjectionExploitAgent(activityInput)
    â†“
runAgentActivity('injection-exploit', input)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Load config                          â”‚
â”‚ 2. Initialize audit session             â”‚
â”‚ 3. Load prompt (exploit-injection.txt) â”‚
â”‚ 4. Create git checkpoint               â”‚
â”‚ 5. Execute Claude Agent SDK             â”‚
â”‚    - Reads queue.json for targets      â”‚
â”‚    - Reads 3 intelligence files:       â”‚
â”‚      â€¢ pre_recon_deliverable.md       â”‚
â”‚      â€¢ recon_deliverable.md           â”‚
â”‚      â€¢ injection_analysis_deliverable.mdâ”‚
â”‚    - Uses TodoWrite to track vulns      â”‚
â”‚    - Attempts exploitation for each     â”‚
â”‚ 6. Validate output                      â”‚
â”‚    â†’ Uses AGENT_VALIDATORS['injection-exploit']â”‚
â”‚    â†’ Check: injection_exploitation_    â”‚
â”‚            evidence.md exists           â”‚
â”‚ 7. If validation passed:               â”‚
â”‚    - Commit git changes                 â”‚
â”‚    - Log metrics                       â”‚
â”‚    - Return AgentMetrics                 â”‚
â”‚ 8. If validation failed:               â”‚
â”‚    - Rollback git workspace            â”‚
â”‚    - Retry agent (max 3 times)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Workflow records metrics:
  state.agentMetrics['injection-exploit'] = metrics
  state.completedAgents.push('injection-exploit')
```

---

### Path 4: Validation Failure â†’ Retry

```
Injection vuln agent completes but validation fails
    â†“
validateAgentOutput() returns false
    â†“
    â”œâ”€ attemptNumber < 3?
    â”‚   â””â”€ Rollback git workspace
    â”‚       Throw "Output validation failed"
    â”‚       Temporal retries runAgentActivity
    â”‚       Agent gets fresh workspace (from rollback)
    â”‚       Agent tries again to create deliverables
    â”‚
    â””â”€ attemptNumber >= 3?
        â””â”€ Throw ApplicationFailure.nonRetryable
            Workflow marks agent as failed
            Workflow continues with other agents
            (if using Promise.allSettled)
```

---

## Security & Reliability Features

### 1. Git Workspace Isolation

**Problem:** Agent execution mutates workspace (creates files, modifies git state)

**Solution:** Checkpoint-Commit-Rollback pattern

```typescript
// Before execution
await createGitCheckpoint(repoPath, agentName, attemptNumber);
// Creates: refs/shannon-checkpoint/<agentName>-<attempt>

// After success
await commitGitSuccess(repoPath, agentName);
// Creates: commit with checkpoint ref parent

// After failure
await rollbackGitWorkspace(repoPath, 'error recovery');
// Resets to: refs/shannon-checkpoint/<agentName>-<attempt>
```

**Benefits:**
- Clean workspace for each retry
- No state leakage between attempts
- Reproducible builds (commit hash in metrics)

---

### 2. Spending Cap Detection

**Problem:** Billing errors (rate limits, spending caps) can manifest as successful completion with 0 cost

**Solution:** Sanity check in activities.ts:183-200

```typescript
// Defense-in-depth: A successful agent execution should never have â‰¤2 turns with $0 cost
if (result.success && (result.turns ?? 0) <= 2 && (result.cost || 0) === 0) {
  const resultText = result.result || '';
  const looksLikeBillingError = /spending|cap|limit|budget|resets/i.test(resultText);

  if (looksLikeBillingError) {
    await rollbackGitWorkspace(repoPath, 'spending cap detected');
    await auditSession.endAgent(agentName, {
      attemptNumber,
      duration_ms: result.duration,
      cost_usd: 0,
      success: false,
      error: `Spending cap likely reached: ${resultText.slice(0, 100)}`,
    });
    // Throw as billing error so Temporal retries with long backoff
    throw new Error(`Spending cap likely reached: ${resultText.slice(0, 100)}`);
  }
}
```

**Why This Works:**
- Normal agent: >10 turns, >$0 cost
- Billing cap: ~1-2 turns, $0 cost (cut off mid-response)
- Regex pattern matching catches error messages

---

### 3. Heartbeat-Based Liveness

**Problem:** Long-running agents (up to 2 hours) can exceed Temporal's timeout

**Solution:** Heartbeat every 2 seconds

```typescript
const heartbeatInterval = setInterval(() => {
  const elapsed = Math.floor((Date.now() - startTime) / 1000);
  heartbeat({ agent: agentName, elapsedSeconds: elapsed, attempt: attemptNumber });
}, HEARTBEAT_INTERVAL_MS);  // 2000ms
```

**Configuration:**
```typescript
// Activity proxy configuration
const acts = proxyActivities<typeof activities>({
  startToCloseTimeout: '2 hours',
  heartbeatTimeout: '10 minutes',  // Must be > heartbeat interval
  retry: PRODUCTION_RETRY,
});
```

**Benefits:**
- Worker signals "I'm alive" every 2 seconds
- Temporal waits up to 10 minutes without heartbeat before marking as failed
- Allows long-running agents (up to 2 hours)

---

### 4. Graceful Pipeline Failure

**Problem:** One pipeline failure shouldn't stop others

**Solution:** Promise.allSettled instead of Promise.all

```typescript
const pipelineResults = await Promise.allSettled([
  runVulnExploitPipeline('injection', ...),
  runVulnExploitPipeline('xss', ...),
  runVulnExploitPipeline('auth', ...),
  runVulnExploitPipeline('ssrf', ...),
  runVulnExploitPipeline('authz', ...),
]);

// Aggregate results
for (const result of pipelineResults) {
  if (result.status === 'fulfilled') {
    // Record metrics
  } else {
    // Log error but continue
    failedPipelines.push(errorMsg);
  }
}
```

**Benefits:**
- Authz pipeline failure doesn't stop injection exploitation
- Partial results still captured
- Workflow completes even if some pipelines fail

---

### 5. MCP Server Race Condition Prevention

**Problem:** Multiple workflows running in parallel could share global state

**Solution:** Factory pattern with closure capture

```typescript
// mcp-server/src/tools/save-deliverable.ts

function createSaveDeliverableHandler(targetDir: string) {
  // targetDir captured in closure - each instance has its own
  return async function save_deliverable(args: SaveDeliverableInput) {
    // Uses targetDir from closure, not global variable
    const filepath = path.join(targetDir, 'deliverables', filename);
    await fs.writeFile(filepath, content);
  };
}

export function createSaveDeliverableTool(targetDir: string) {
  return tool(
    'save_deliverable',
    'Saves deliverable files with automatic validation...',
    SaveDeliverableInputSchema.shape,
    createSaveDeliverableHandler(targetDir)  // Creates fresh closure
  );
}
```

**Usage in worker:**
```typescript
// Each workflow gets its own MCP server instance
const shannonHelperServer = createShannonHelperServer(sourceDir);
// No race conditions even with multiple parallel workflows
```

---

### 6. Dual Deliverable Enforcement

**Problem:** Agent might forget to create queue file, triggering false positives

**Solution:** Symmetric validation in queue-validation.ts:110-115

```typescript
// Both must exist together (prevents partial analysis from triggering exploitation)
const fileExistenceRules = Object.freeze([
  createValidationRule(
    ({ deliverableExists, queueExists }) =>
      deliverableExists && queueExists,  // BOTH required
    getExistenceErrorMessage
  ),
]);
```

**Validation Matrix:**

| deliverable | queue | Result |
|-------------|-------|--------|
| âœ… exists | âœ… exists | âœ… Pass â†’ Check queue content |
| âŒ missing | âŒ missing | âŒ Fail â†’ Retry vuln agent |
| âœ… exists | âŒ missing | âŒ Fail â†’ Retry vuln agent (forgot queue) |
| âŒ missing | âœ… exists | âŒ Fail â†’ Retry vuln agent (unlikely) |

**Error Messages Guide Agent:**
```javascript
// Agent sees this error when calling save_deliverable:
{
  status: 'error',
  message: 'Invalid queue structure: Missing or invalid 'vulnerabilities' array.
   Expected: {"vulnerabilities": [...]}',
  deliverableType: 'INJECTION_QUEUE'
}

// Agent fixes by ensuring queue has correct structure:
await save_deliverable({
  deliverable_type: 'INJECTION_QUEUE',
  content: JSON.stringify({
    vulnerabilities: [
      {
        ID: 'INJ-VULN-01',
        externally_exploitable: true,
        verdict: 'vulnerable',
        // ... other required fields
      }
    ]
  })
});
```

---

### 7. Output Validation Retry Limits

**Problem:** Some validation failures don't self-heal (persistent agent bugs)

**Solution:** Lower retry limit for validation failures

```typescript
const MAX_OUTPUT_VALIDATION_RETRIES = 3;  // vs 50 for other errors

if (!validationPassed) {
  await rollbackGitWorkspace(repoPath, 'validation failure');

  if (attemptNumber >= MAX_OUTPUT_VALIDATION_RETRIES) {
    throw ApplicationFailure.nonRetryable(
      `Agent ${agentName} failed output validation after ${attemptNumber} attempts`,
      'OutputValidationError',
      [{ agentName, attemptNumber, elapsed: Date.now() - startTime }]
    );
  }
  throw new Error(`Agent ${agentName} failed output validation`);
}
```

**Why Lower Limit:**
- Agent that doesn't create deliverable on attempt 1 likely won't on attempt 50
- Prevents wasting API calls on permanent failures
- Non-retryable error stops workflow cleanly

---

## Summary

### Validation Flow Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AGENT EXECUTION WITH 3-LAYER VALIDATION                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ Layer 1: MCP Tool Validation (Real-time) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚ Agent calls:                                                        â”‚
â”‚   save_deliverable({                                                â”‚
â”‚     deliverable_type: 'INJECTION_QUEUE',                          â”‚
â”‚     content: '{"vulnerabilities": [...]}'                         â”‚
â”‚   })                                                                â”‚
â”‚                                                                   â”‚
â”‚ MCP tool validates:                                                â”‚
â”‚   âœ“ Is deliverable_type valid enum?                               â”‚
â”‚   âœ“ Is content non-empty?                                         â”‚
â”‚   âœ“ Is deliverable_type a queue type?                             â”‚
â”‚   âœ“ Does content parse as valid JSON?                             â”‚
â”‚   âœ“ Does JSON have "vulnerabilities" array?                       â”‚
â”‚                                                                   â”‚
â”‚ Tool returns:                                                       â”‚
â”‚   { status: 'success', validated: true, filepath: '...' }        â”‚
â”‚                                                                   â”‚
â”‚ Agent proceeds                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€ Layer 2: Agent Output Validation (Post-execution) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚ runAgentActivity() calls:                                         â”‚
â”‚   validateAgentOutput(result, 'injection-vuln', sourceDir)      â”‚
â”‚                                                                   â”‚
â”‚ Validator function checks:                                         â”‚
â”‚   âœ“ Agent completed successfully?                                  â”‚
â”‚   âœ“ Does validator exist for this agent?                          â”‚
â”‚   âœ“ validateQueueAndDeliverable('injection', sourceDir)        â”‚
â”‚     âœ“ Both files exist?                                          â”‚
â”‚     âœ“ Queue JSON structure valid?                                â”‚
â”‚     âœ“ Queue has vulnerabilities array?                             â”‚
â”‚                                                                   â”‚
â”‚ If validation passes:                                              â”‚
â”‚   âœ“ Commit git workspace                                         â”‚
â”‚   âœ“ Log success metrics                                            â”‚
â”‚   âœ“ Return AgentMetrics                                           â”‚
â”‚                                                                   â”‚
â”‚ If validation fails:                                              â”‚
â”‚   âœ— Rollback git workspace                                      â”‚
â”‚   âœ— Log failure metrics                                           â”‚
â”‚   âœ— Retry agent (max 3 times for validation errors)            â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€ Layer 3: Queue Validation (Pre-exploitation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚ Workflow calls checkExploitationQueue(input, 'injection'):       â”‚
â”‚                                                                   â”‚
â”‚ Function calls:                                                     â”‚
â”‚   safeValidateQueueAndDeliverable('injection', sourceDir)        â”‚
â”‚     â†’ validateQueueAndDeliverable (full pipeline)               â”‚
â”‚                                                                   â”‚
â”‚ Checks:                                                             â”‚
â”‚   âœ“ deliverables/injection_analysis_deliverable.md exists?       â”‚
â”‚   âœ“ deliverables/injection_exploitation_queue.json exists?      â”‚
â”‚   âœ“ Queue JSON structure valid?                                   â”‚
â”‚   âœ“ vulnerabilities.length > 0?                                     â”‚
â”‚                                                                   â”‚
â”‚ Returns ExploitationDecision:                                     â”‚
â”‚   { shouldExploit: true, vulnerabilityCount: 3, vulnType: 'injection'} â”‚
â”‚                                                                   â”‚
â”‚ Workflow decision:                                                   â”‚
â”‚   if shouldExploit:                                                â”‚
â”‚     â†’ Run injection-exploit agent                                   â”‚
â”‚   else:                                                             â”‚
â”‚     â†’ Skip exploitation (mark complete, no API calls)             â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Exploitation Flow Summary

```
â”Œâ”€ PIPELINE: Injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚ Step 1: Run injection-vuln agent                                  â”‚
â”‚   - Analyzes code for injection vulnerabilities                    â”‚
â”‚   - Uses save_deliverable to create:                             â”‚
â”‚     â€¢ injection_analysis_deliverable.md                            â”‚
â”‚     â€¢ injection_exploitation_queue.json                            â”‚
â”‚       [{                                                         â”‚
â”‚         ID: 'INJ-VULN-01',                                     â”‚
â”‚         externally_exploitable: true,                           â”‚
â”‚         verdict: 'vulnerable',                                   â”‚
â”‚         witness_payload: "'",                                    â”‚
â”‚         confidence: 'high'                                        â”‚
â”‚       }]                                                         â”‚
â”‚   - Validates output (both files must exist)                      â”‚
â”‚   - Git commit                                                   â”‚
â”‚                                                                   â”‚
â”‚ Step 2: Check exploitation queue                                   â”‚
â”‚   - Validate queue structure                                      â”‚
â”‚   - Count vulnerabilities: 3                                       â”‚
â”‚   - Decision: shouldExploit = true                               â”‚
â”‚                                                                   â”‚
â”‚ Step 3: Run injection-exploit agent (CONDITIONAL)               â”‚
â”‚   - Only runs if shouldExploit=true                               â”‚
â”‚   - Reads queue.json for targets                                  â”‚
â”‚   - Reads 3 intelligence files for context                        â”‚
â”‚   - Uses TodoWrite to track 3 vulnerabilities                  â”‚
â”‚   - Attempts exploitation for each:                               â”‚
â”‚     â€¢ Confirm vulnerability (e.g., inject "'")                   â”‚
â”‚     â€¢ Enumerate database (e.g., table names)                     â”‚
â”‚     â€¢ Exfiltrate data (e.g., user records)                        â”‚
â”‚   - Uses save_deliverable to create:                             â”‚
â”‚     â€¢ injection_exploitation_evidence.md                           â”‚
â”‚   - Validates output (evidence file must exist)                    â”‚
â”‚   - Git commit                                                   â”‚
â”‚                                                                   â”‚
â”‚ Result: 3 vulnerabilities exploited with evidence                â”‚
â”‚   (or 0 if queue was empty)                                       â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Reliability Features

| Feature | Implementation | Benefit |
|---------|---------------|---------|
| **Git Checkpointing** | Checkpoint before agent, commit on success, rollback on failure | Clean workspace for retries |
| **Heartbeat Loop** | Signal every 2s during agent execution | Prevents timeout for long-running agents |
| **Spending Cap Detection** | Check for â‰¤2 turns + $0 cost pattern | Catch billing errors that slip through |
| **Dual Deliverable Enforcement** | Both analysis.md AND queue.json must exist | Prevent partial analysis from triggering exploitation |
| **Queue JSON Validation** | Schema validation in MCP tool + queue-validator.ts | Ensures correct structure before exploitation |
| **Graceful Pipeline Failure** | Promise.allSettled for parallel pipelines | One failure doesn't stop others |
| **Conditional Exploitation** | shouldExploit gate before running exploit agent | Save time and API costs when no vulns found |
| **Error Classification** | Retryable vs non-retryable with 50-attempt billing retry | Intelligent retry strategy |
| MCP Factory Pattern | Closure capture for targetDir prevents race conditions | Safe parallel workflow execution |
| **Output Validation Retry Limit** | Max 3 retries for validation failures | Prevents infinite retries on permanent failures |

---

**END OF DOCUMENT**
